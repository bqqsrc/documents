# Gson使用规范

---
## 前言
gson是作者为自己设计的一种轻量级的数据交换格式。


这个的设计并非心血来潮的设计，这个设计产生的原因是json、xml等的数据格式无法满足作者的需求，同时又没有找到符合需求的一种第三方数据交换格式的实现，因此设计了这样一套数据交换格式规范。


gson的全称叫Go Script Object Notation，其名称参考自json（JavaScript Object Notation），因为其第一个实现是用go写的，取了该名称。


这种数据交换格式设计之初只是为了作者自己使用，因此，它并不一定比json、xml这些数据交换格式要好用，也可能没有网上一些开源作品要好用，所以如果你觉得这个设计不适用于你自己，使用起来并不方便，你完全可以不采用这种格式，当然如果你觉得这种格式刚好符合你的需求，那么非常欢迎你使用


---
## gson的新特性
gson是一种和json类似的格式，相比json，添加了以下的特点：
1. gson允许添加注释
2. gson字符串前后不需要添加双引号
3. gson允许添加换行字符串
4. gson没有逗号进行分隔

---
## gson的语法
### 构造字符
gson保留以下6个字符作为构造字符，以下是gson的构造字符一览表：

|构造字符|名称|作用|使用范例|
|---|---|---|---|
|:|键定义构造字符|定义一个键|```root: /User/testpath/test.gs```|
|{|对象起始构造字符|标志一个对象的起始构造字符|```Obj: { ele1: 33.5 }```|
|}|对象结尾构造字符|标志一个对象的结尾构造字符|同上|
|\`|强制字符串构造字符|标志一个字符串的起始字符|numstr: \`35.898\`|
|%|转义字符|对构造字符进行转义|mapstr: %{aa%:3,bb%:4%}|
|#|注释符|添加一段注释|```prefix: /Users/goper/conf/goper.gs #goper的配置文件路径```|

后面有专门对这些构造字符的详细说明和使用范例

### 键要求
gson的键要求不能包含构造字符，不能包含空格

### 值要求
gson的值可以是字典、数组（当前版本只支持一维数组）、数字、字符串、布尔型的true、布尔型的false、nil，字符串不需要使用单引号、双引号等包起来表示，gson会在解析时，根据数据自动解析为一个最合适的数据类型

---
## 构造字符详解
### 键定义构造字符（:）
键定义构造字符是一个英文的冒号，通过“键名:”的格式定义一个键，键名和冒号之间如果存在无意义的空白符（空格、换行、回车等），这些空白符将会被忽略


gson在编码时，会临时保留最后扫描出来的一个字符串，当扫描到键定义构造字符（:）时，会将该构造字符前面的字符串作为一个键来处理，其后面的值将作为这个键对应的值，直到扫到新的一个键


gson的键不需要用单引号、双引号括起来，目前不支持中文字符以及其他unicode字符


键定义构造字符的使用范例

- 定义一个root键，值为字符串/User/testpath/test.gs

```
root: /User/testpath/test.gs     
```

- 定义一个num键，值为数字35.8

```
num : 35.8
```

- 定义一个done键，值为布尔值false

```
done: false
```

### 对象构造字符（{}）
对象即一组键值对的组合，相当于json的对象，在go语言中，相当于一个map[string]interface{}


一组大括号是标志了一个对象，所以“{}”必须成对使用


对象中的值可以是任何gson支持的数据类型


“{}”也可以嵌套使用


对象构造字符的使用范例

- 定义一个对象Obj

```
Obj: {
   ele1: 33.5
   ele2: ele2_str
   ele3: {
      subele1: true
      subele2: 33.5 57.3 89
   }
}
```

以上定义了一个对象，包含ele1键，值为数字33.5，ele2键，值为字符串ele2_str，ele3键，值是一个新的对象，该子对象包含subele1键，值为布尔型true，subele2键，值为数字数组

### 强制字符串构造字符（`）
\` 这个构造字符是反引号，在键盘上左上角的位置，打波浪线（~）的那个键，在英文模式下即可打出来


一对 \` 括起来的字符，会原封不动的被当做一个字符串处理，赋值给对应的键，包括所有的空白字符，构造字符等，这里有一个例外：一个连续的%\`将会被解析为单独的\`


正常情况下，gson的值的是不需要添加任何引号、双引号来判断它是不是字符串的，gson在解析时会根据数据自动选择最合适的类型，但是有时候需要定义数值字符串、true字符串、false字符串等，那么就需要用这个构造字符包起来表示这是一个字符串。另外，有时候要在字符串里面添加换行符、构造字符、空格符等，也可以直接用这个构造字符包起来


这个构造字符可以用于以下几种情况：

* 字符串中包含构造字符，又不想用繁琐的转义字符来转义所包含的构造字符
* 要将数值、true、false、nil作为字符串处理
* 字符串中包含空格、换行符等空白字符
* 其他你认为需要的情况



这个构造字符可以表示所有你想要表示的数据，包括一段代码


gson在解析时，两个单一的 \` 之间的字符会处理为一个字符串，赋值给对应的键，这里要求是单一的 \`，也就是如果起始为一个单独的 \` ，结尾也必须和起始的一样是一个单独的 \`，不能是连续的2个或者2个以上


如果字符串里面同时包含了强制字符串 \`，这个时候可以把起始和结尾的单一的 \` 同时改为两个连续的 \`（即\`\`），来将字符串括起来，如果字符串里面包含了连续的两个 \`，则用回单一的 \`括起来


要是字符串同时包含了 \` 和 \`\`，那么可以用三个 \`（即\`\`\`）括起来，gson最多支持两对连续3个 \` ，来括起一个字符串，因为3个\`已经足够平时的情况使用了，目前为止，作者在字符串中出现最多的也就只是1个\`，如果3个\`都无法满足需求，那么这种情况不在gson的考虑范围内，可以通过%\`转义的方式去实现


事实上，3个\`和转义%\`，已经可以表达所有的字符串了


gson在解析的时候，如果发现 \`字符，会标记为后面的所有字符都将是一个字符，而不做任何处理，如果继续扫描发现还是\`，则不将这个\`纳入字符串的一部分，而是将\`的数目加1，直至最后找到同等数量的\`且后续不再有\`的条件，字符串构造就终止了，扫描过程中，除了将%\`处理为\`，其余的字符都将原封不动的处理为字符串的字符


强制字符串构造字符的使用范例

- 定义一个数值字符串

```
numstr: `35.898`
```
 
- 定义一个带空格的字符串

```
code: `
  a = 3
  b = 5
  print(a + b)
`
```

- 定义一个带`的字符串

```
code: ``
   dir_list=`ls $root`
``
```


如果字符串的首字符或者尾字符是\`，那么这时为了避免将这个\`解析为构造字符，需要添加转义，例如，下面的字符串

```
echo_str: ``echo $aa``
```

会被解析为echo_str的值为字符串"echo $aa"，而实际有可能是希望它解析为"\`echo $aa\`"，此时就应该按照下面的定义

```
echo_str: `%`echo $aa%``
```


另外，`字符也作为注释的换行支持解析，这部分在注释时会讲到

### 转义构造字符（%）
和几乎所有编码格式一样，gson也有一个转移字符，用来标志构造字符不要进行解析，当给一个键设置值的时候，只要出现了构造字符，都应该在其前面添加%来进行转义，否则这些构造字符将会参与编码的解析，导致得到的结果不符合预期甚至出错。以下列出了所有构造字符作为普通字符时的正确写法：

|构造字符|转义写法|
|---|---|
|:|%:|
|{|%{|
|}|%}|
|\`|%\`|
|%|%%|
|#|%#|
|=|%=|
|$|%$|
|@|%@|
|!|%!|


在键名定义中，转义字符的解析和在值定义是一样的，正常情况下键的定义是不允许出现构造字符的，不过gson作为一种容错性高的数据格式，也会对这种情况做出处理


转义字符的使用范例

- 定义一个带:的字符串

```
winpath: E%:/path1/path2
```


这里有几种情况值得特别说明：

* 强制字符串构造符之间的构造字符是不需要进行转义的，且强制字符串构造符之间的%也会进行转义，除了%`
* 要表示%时，需要使用%%表示，否则可能会出现意想不到的解析错误，例如所以下面的键值会被解析为：express: 50=0.5，因为=也是一个构造字符，正确的值的写法应该是50%%=0.5

```
express: 50%=0.5
```

* 单独的一个%，或者%后面跟着的不是构造字符，则%会被作为普通字符串保留，例如下面的键值则会解析为：percent: 50%

```
percent: 50%
```

* 转移字符在注释中不会做任何转义

### 注释符（#）
gson用#来标志一段注释，在某一行中，#之后的所有字符都将被作为注释处理，不做参与具体数据的解析，直到发现换行符


单个#只能用于单行的注释，如果是多行注释，可以在#后紧接着跟上强制字符串解析符，此时gson编码器会尝试寻找合适数量的强制字符串解析符来终止注释


注释符的使用范例

- 单行注释

```
root: /Users/goper/aa   #某个路径
```

- 多行注释

```
#`该配置用于指定数据库的相关数据
name：用户名
pass：密码
db：数据库名`
name: test
pass: 123456
db: goper.db
```


特别注意2点：

* 除非当前在注释字符串中，或者在强制字符串中，否则%#将表示一个普通的#，而不是一个注释的开始
* 多行注释后的起始强制字符串解析符要紧跟着#，否则强制字符串解析符也会被作为注释处理

### gson的数组
gson允许设置其值为数组，数组之间的元素直接以空格来分隔，另外


gson的根级必然是一个对象，因此，根级的对象符是不需要添加的

### gson对重复定义的处理
由于gson的最初使用是用于goper的配置项，因此作者希望gson是一个容错性较强的数据格式，也因为goper是一个web服务器实现，有大量的重复定义键的需求，因此，当对象中同一个键出现多次定义时，gson是不会报错的，而是会把后面的键的值直接与前面的值直接合并为一个数组，如果这些键的值是一个对象，则会合并其对象的键值


---
## 使用建议
gson是为作者自己设计的数据格式，因此很多设计是从作者自己的实践经历出发的


gson虽然作为一种容错性强的数据交换格式，对多种情况做出了处理，但是在使用中，还是应该规范使用。其设计之初就是作为一种轻量的配置文件使用，因此它并不适合复杂的数据格式。

事实上，如果要想实现json的功能，仅需键定义符（:）、对象定义符（{和}）、强制字符串标志符（`）就足够了

如果你觉得gson的语法规则过于繁杂，难以理解，说明这种数据交换格式不适用于你的需求，那么建议你选择更加适合你的数据交换格式

---