读懂Go的GMP模型（二）——Go的GMP
===

- 作者：晓白齐齐
- 更新：2024.1.10

- 本文用于记录作者学习过程的心得理解，限于作者水平有限，可能存在理解错误，欢迎提出。
- 本文中多处引用他人文章的图表，在图表引用一栏均有列出出处，如有侵权，联系作者删除，还请见谅。
- 参考文档一栏列出了本文参考的文档。
- 本文禁止转载，因为经过多次转载会导致文章内容与原文存在差异，或者图表丢失，导致文章质量下降。

---
## 一、 Go 的协程
Go 中，协程称为 goroutine ，通过关键字 go 触发。一个协程只占几KB，这与一个线程动则 1MB 以上来说轻量了很多。 goroutine 的栈是可伸缩的，当需要更多内容时， runtime 会自动为 goroutine 分配。

goroutine 有以下两个优点：
   - 占用更小的内存。
   - 调度更灵活（runtime调度）。

---
## 二、废弃的旧版协程调度器
本文不过多介绍旧版的调度器的历史，[这篇文章](https://learnku.com/articles/41728)有对旧版的调度器进行简单讲解。与其他文章一样，<span style="color: red">本文用 M 代表线程， G 代表 goroutine ， P 代表后面提到的 Processor 。</span>

<center><img src=./source/52/1.调度器符号.png width=400 float=center>

图1. 调度器符号<sup>[1]</sup></center>

<center><img src=./source/52/2.旧版调度器.png width=500 float=center>

图2. 旧版调度器<sup>[2]</sup></center>

总的来说，旧版的调度器只有 M 和 G ，存在以下几个缺点：
   1. 多个 M 通过访问全局 G 队列执行、放回 G ，需要对全局 G 队列加锁进行保护，形成了激烈的锁竞争。
   2. M 转移 G 会造成延迟和额外的系统负载，并且存在很差的局部性。例如一个 G 包含创建新的 G 的操作时，且 G 绑定在 M 的情景下， M 会创建一个新的协程 G' ， M 为了继续执行 G ，需要将 G' 交给另一个线程 M' ， M 将 G' 转移到 M' 造成了一定的延迟和系统负载。因为 G 和 G' 是相关的，所以最好将 G' 放到 M 执行而不是 M' ，所以这是较差局部性的表现。
   3. 系统调用（ CPU 在 M 之间的切换）导致频繁的线程阻塞和取消阻塞存在，造成了系统开销。

---
## 三、 Goroutine 调度器的 GMP 模型的设计思想
### （一） Processor 处理器
新版的调度器除了 M （ thread ） 和 G （ goroutine ）， 引进了 P （ processor ） 处理器的概念。

Processor 包含运行 G 的资源，还包含了可运行的 G 队列， M 想要运行 G 需要先获取 P 。

### （二） GMP 模型
在 Go 中，协程是由线程运行的，而调度器的功能则是将可运行的协程分配到工作线程上，因此 G、 M 、 P 都是调度器的一部分，这就是 GMP 调度模型。

<center><img src=./source/52/3.新版调度器符号.png width=400 float=center>

图3. 调度器符号<sup>[3]</sup></center>

<center><img src=./source/52/4.新版调度器.jpg width=600 float=center>

图4. 新版调度器<sup>[4]</sup></center>

GMP 模型的理解： 
   1. P 列表： 程序启动时创建 P 列表，保存在数组中，最多有 GOMAXPROCS (可配置) 个 P 。
   2. 全局队列： 存放着等待运行的 G ， P 列表中的 P 都可以向全局队列获取或添加要运行的 G ，因此需要为这个全局队列加锁。
   3. P 的本地队列： 每个 P 都有一个本地 G 队列，存放着等待运行的 G ，最多不超过256个。当拥有 P 的 M 新建一个协程 G' 时，会优先将 G' 放到 P 的本地 G 队列。如果本地队列满了，会把本地队列的一半 G 移动到全局队列。
   4. M： 线程需要获取到 P ，才能从 P 中获取到等待运行的 G 。优先从 P 的本地队列获取 G ，如果 P 的本地队列为空时，则 M 会尝试从全局队列拿一批 G 放到 P 的本地队列，如果从全局队列获取不到 G ，则从其他的 P 的本地队列偷一半到自己 P 的本地队里。 M 拿到 G 后执行，执行完拿到的 G 后，从 P 获取下一个 G ，如此重复。执行过程中如果生成新的协程 G' ，则将 G' 优先放到自己的 P 的本地队列，当自己的 P 的本地队列满了，则移动一半 G 到全局队列。

以上是 GMP 调度器的模型， GMP 调度器通过 M 连接 操作系统调度器， OS 调度器负责将内核线程分配到 CPU 核运行。

### （三）通过可视化 GMP 编程分析 GMP 模型
可以通过两种方式可以查看程序的 GMP 数据：
   1. go tool trace 
   2. Debug trace

本文将通过第1种方式来分析 GMP 的可视化流程，第2种方式可通过[这篇文章](https://learnku.com/articles/41728)进行了解，本文不将该方式。

#### 方式一： go tool trace
1. 运行下面的代码 trace.go
   
   ```
   package main

   import (
      "fmt"
      "os"
      "runtime/trace"
   )

   func main() {

      //创建trace文件
      f, err := os.Create("trace.out")
      if err != nil {
         panic(err)
      }

      defer f.Close()

      //启动trace goroutine
      err = trace.Start(f)
      if err != nil {
         panic(err)
      }
      defer trace.Stop()

      //main
      fmt.Println("Hello World")
   }
   ```

   运行程序

   ```
   $ go run trace.go
   Hello World
   ```

   这段代码调用 runtime/trace 的 Start 函数将 GMP 数据记录到 trace.out 文件中。

2. 打开 trace.out 文件

   运行后得到一个 trace.out 文件，这个文件是个二进制文件，可以使用 go tool trace 打开分析：
   
   ```
   $ go tool trace trace.out
   2024/01/10 19:13:26 Parsing trace...
   2024/01/10 19:13:26 Splitting trace...
   2024/01/10 19:13:26 Opening browser. Trace viewer is listening on http://127.0.0.1:2738 
   ```

   此时可以通过打开浏览器 ```http://127.0.0.1:2738``` 网址，点击 ```view trace``` 查看程序的 GMP 调度流程，网址的端口不是固定的，在运行 ```go tool trace trace.out``` 输出的最后一行可以看到。

   可以看到 GMP 调度可视化图：
   
   <center><img src=./source/52/5.GMP可视化界面.png width=1200 float=center>

   图5. GMP可视化界面</center>

   点击右上角的 ```Flow events``` 按钮，勾选 All ，可以显示发生的事件。如下图所示：
   
   <center><img src=./source/52/6.可视化界面显示event.png width=400 float=center>

   图6. 可视化界面显示event</center>

3. 分析 GMP 信息
   
   可视化界面的 x 轴表示程序运行的时间， y 轴为各项 GMP 数据。

   <center><img src=./source/52/7.GMP可视化x.y轴.png width=1200 float=center>

   图7. GMP可视化x.y轴</center>

   x 轴的单位不是固定微秒，根据实际进程运行的时间长度决定。







### （四）调度流程和调度器的生命周期


### （三） P 和 M 的个数和创建时机



P 列表的 GOMAXPROCS 可以设置为操作系统核数，这样创建来运行 P 的线程数就跟操作系统核数一致，每个 CPU 核一个线程，既充分利用了操作系统的多核能力，也减少了线程之间的切换的开销。

---
## 四、 Go 的调度器调度场景过程全解析

---
## 总结

---
## 面试问题
1. 了解 GMP 模型吗，介绍一下？
2. 讲讲 golang 的调度模型，go 调度中阻塞都有那些方式
3. GPM 模型里如果本地队列满了，新增的 g 会怎么处理
   - 会与队列前半部分的g随机混合，然后取一半到全局队列
4. GO 语言中的协程与 Python 中的协程的区别？
5. Go 协程简单用法，goroutine的实现

---
## 提出新问题
1. 什么是锁竞争
2. 如果一个 G 阻塞了， 运行 G 的 M 也会阻塞？当有海量的 G 阻塞，也会创建海量的 M 吗


---
## 图表引用
- [1， 2, 3, 4] https://learnku.com/articles/41728


---
## 参考文档
- [Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
- [Golang并发模型GMP](https://zhuanlan.zhihu.com/p/261057034)

---
## 参考链接
3. [Go协程模型——GMP模型](https://juejin.cn/post/7097582959795896327)
4. [Go 面试官：GMP 模型，为什么要有 P？](https://juejin.cn/post/6968311281220583454)
5. [一文看懂Go语言协程的设计与原理](https://juejin.cn/post/7044741465930465311)
6. [【深入理解Go】协程设计与调度原理（上）](https://segmentfault.com/a/1190000040710568)
7. [【深入理解Go】协程设计与调度原理（下）](https://segmentfault.com/a/1190000040713660)

---