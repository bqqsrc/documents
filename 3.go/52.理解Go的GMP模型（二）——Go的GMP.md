理解Go的GMP模型（二）——Go的GMP
===

- 作者：晓白齐齐
- 更新：2024.1.12
- 声明：本文用于记录作者学习过程的心得理解，限于作者水平有限，可能存在理解错误，欢迎提出。参考文档一栏列出了本文参考的文档，本文的一些图表来自这些参考文档，如有侵权，联系作者删除，还请见谅。<font color="red">为避免转载导致的文章质量下降，本文禁止转载。</font>

---
## 一、 Go 的协程
Go 中，协程称为 goroutine 。一个协程初始只占 2KB 左右，这与一个线程动则几 MB来说轻量了很多。 

goroutine 有以下两个优点：
1. 占用更小的内存。
2. 调度更灵活（runtime调度）。

---
## 二、 GMP 的各个字母的意义
- G : 表示 goroutine ，每个 goroutine 都有自己的栈空间、定时器。初始化的栈空间在 2kB 左右，runtime 会根据 goroutine 的需求自动分配空间，所以 goroutine 的栈是可伸缩的， 会随着需求增长。
- M : 表示内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息。
- P : 代表调度器的处理器，负责调度 goroutine ，维护一个本地 goroutine 队列，同时包含了可运行的 goroutine 的资源，负责部分内存的管理， M 从 P 上获得 goroutine 并执行。

---
## 三、废弃的旧版协程调度器
以下图示展示了旧版的调度器模型：

<center><img src=./source/52/1.调度器符号.png width=400 float=center>

图1. 调度器符号</center>

<br>

<center><img src=./source/52/2.旧版调度器.png width=500 float=center>

图2. 旧版调度器</center>

<br>

旧版的调度器没有 P ，只有 M 和 G ，存在以下几个缺点：
1. 多个 M 通过访问全局 G 队列获取、放回 G ，需要对全局 G 队列加锁进行保护，多个 M 创建、销毁、调度 G 形成了激烈的锁竞争。
2. M 转移 G 会造成延迟和额外的系统负载，并且存在很差的局部性。例如一个 G 包含创建新的 G 的操作时，且 G 绑定在 M 的情景下， M 会创建一个新的协程 G' ， M 为了继续执行 G ，需要将 G' 交给另一个线程 M' ， M 将 G' 转移到 M' 造成了一定的延迟和系统负载。因为 G 和 G' 是相关的，所以最好将 G' 放到 M 执行而不是 M' ，所以这是较差局部性的表现。
3. 系统调用（ CPU 在 M 之间的切换）导致频繁的线程阻塞和取消阻塞存在，造成了系统开销。

---
## 四、 GMP 模型
### 1.GMP 模型的设计思想
新版的调度器引入了 P 的概念，如果 M 想运行 G ，就必须先获取 P 。以下图示展示了新版的调度器模型：


<center><img src=./source/52/3.新版调度器符号.png width=400 float=center>

图3. 调度器符号</center>

<br>

<center><img src=./source/52/4.新版调度器.jpg width=600 float=center>

图4. 新版调度器</center>

<br>

简单解释图示中的各部分：
- P 列表： 程序启动时创建 P 列表，保存在数组中，最多有 GOMAXPROCS (可配置) 个 P 。
- 全局队列： 存放着等待运行的 G ， P 列表中的 P 都可以向全局队列获取或添加要运行的 G ，因此需要为这个全局队列加锁。
- P 的本地队列： 每个 P 都有一个本地 G 队列，存放着等待运行的 G ，最多不超过256个。当拥有 P 的 M 新建一个协程 G' 时，会优先将 G' 放到 P 的本地 G 队列。如果本地队列满了，会把本地队列的一半 G 移动到全局队列。
- M： 线程需要获取到 P ，才能从 P 中获取到等待运行的 G 。优先从 P 的本地队列获取 G ，如果 P 的本地队列为空时，则 M 会尝试从全局队列拿一批 G 放到 P 的本地队列，如果从全局队列获取不到 G ，则从其他的 P 的本地队列偷一半到自己 P 的本地队里。 M 拿到 G 后执行，执行完拿到的 G 后，从 P 获取下一个 G ，如此重复。执行过程中如果生成新的协程 G' ，则将 G' 优先放到自己的 P 的本地队列，当自己的 P 的本地队列满了，则移动一半 G 到全局队列。
- 操作系统调度器：OS 调度器不是 GMP 调度器模型的一部分， GMP 调度器主要包括以上的四部分， GMP 调度器通过 M 连接 OS 调度器， OS 调度器负责将内核线程分配到 CPU 核运行。

### 2. P 和 M 的个数
1. P 的数量：
	- 由环境变量 $GOMAXPROCS 或者 runtime 的方法 GOMAXPROCS() 的返回值决定。同一时刻至多只有 GOMAXPROCS 个 goroutine 在同时运行。
	- P 的数量取值优先级，先使用 GOMAXPROCS() 设置的值；如果 GOMAXPROCS() 没有设置或设置了无效值（小于等于 0 ），取环境变量 $GOMAXPROCS 的值；如果环境变量 $GOMAXPROCS 没有设置或设置了无效值，默认为 CPU 核数，这里的 CPU 核数是机器的逻辑处理器的数量，而不是物理内核数量（逻辑处理器数量有可能会多于物理内核数量）。
2. M 的数量：
	- go 程序启动后会默认设置 M 的最大数量为 10000 。
	- 代码中可以通过 runtime/debug 中的 SetMaxThreads 函数设置了 M 的最大数量。
	- 如果 SetMaxThreads 的值设置过低，导致无法生成足够 M 来支持 G 的运行，会报线程数量受限的错误。
3. P 和 M 的数量关系：
	- M 与 P 没有决定关系，一个 M 阻塞， P 就会去创建或者切换到另一个 M ，所以 P 的默认数量为1，也可能会创建很多个 M 出来。

### 3. P 和 M 的创建时机
1. P 的创建时机：
	- 程序运行时，会先创建默认数量 GOMAXPROCS 的 P 队列，这个默认数量是环境变量的 $GOMAXPROCS 或 CPU 核数。
	- 如果调用了 GOMAXPROCS() 函数设置了新的 P 最大数量 n ，运行时系统会根据这个数量 n 调整 P 队列，有可能会需要创建新的 P 。
2. M 的创建时机：
	- 没有足够的 M 来关联 P 运行其中可运行的 G ，会创建 M 。有以下两种情况：
		1. 虽然所有的 P 都绑定了 M 运行，但是存在某个 M 阻塞了，而对应的 P 中还有很多就绪 G ， P 就会寻找其他空闲的 M ，没有空闲的 M ，就会创建新的 M 。
		2. M 的数量较少，没有将所有的 P 都绑定处理，且有很多新的就绪的 G 时，也会创建新的 M 来绑定未工作的 P 来处理 G 。
	- 所以如果调用 SetMaxThreads 设置当 M 的最大数量太小以至于无法满足以上 2 种情况时，就会报线程数量受限的错误。 

### 4. GMP 的调度策略
- 复用线程： GMP 对线程复用避免频繁的创建、消耗线程。
	1. work stealing 机制
		- 当本线程无可运行的 G 时，尝试从全局队列获取 G ，如果不能从全局队列获取 G ，则尝试从其他线程绑定的 P 偷取 G ，而不是销毁线程。

	2. hand off 机制
		- 当本线程因为 G 进行系统调用造成阻塞时，线程释放绑定的 P ，此时 P 会去寻找其他空闲的线程或创建新的线程以继续执行 P 中其他就绪的 G 。

- 利用并行： GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行，充分利用了并发程度， GOMAXPROCS 如果设置少于 CPU 核数，也限制了并发的程度。

- 抢占： 一般的协程要等待协程主动让出 CPU 才执行下一个线程，在 Go 中，一个 G 最多占用 CPU 10ms ，防止其他的 G 被饿死。（TODO:有待验证）

- 局部队列： 每个 P 都维护着自己的一个本地 G 队列，减少了不同 P 访问全局队列带来的竞争等问题，也提高了运行时的局部性。

- 全局队列： 全局队列很好的协调不同了 P 之间的 G 的调度。
	1. 当 P 的本地队列满了，则将本地队列的一半转移到全局队列。
	2. 当 P 的本地队列空了，则先从全局队列获取部分 G 到 P 的本地队列执行。

### 5. GMP 的调度流程
Go 中通过关键字 go 来启动一个协程，任何函数都可以作为一个协程使用，没有添加 go 关键字则是普通的函数调用，添加了 go 关键字则是开启协程。

以下图示展示了一个 go func() 的调度流程：

<center><img src=./source/52/5.调度流程.jpg width=800 float=center>

图5. 调度流程</center>

<br>

具体流程如下：

1. go func() 创建一个 G：
	- 任何一个 G 都是在另一个已经在执行的 G' 通过 go 关键字调用创建的（图示的 1 步骤），此时 G' 必然已经有线程 M1 正在执行，且线程 M1 必然绑定了一个 P。
	- G 只能运行在 M 中，一个 M 必须也只能持有一个 P ， M 和 P 是 1:1 的关系。

2. G 推入队列：
	- 有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。
	- 优先将 G 推入 P 的本地 G 队列（图示的 2 步骤）。
	- 如果 P 的本地 G 队列已满，则将本地 G 队列的一半和 G 一同推入全局队列（图示的 2.1 步骤）。
	- G 入队列后等待执行。

3. M 获取 G ：
	- M1 执行完正在执行的 G 后会继续从 P 的本地队列获取其他 G 继续执行，直至本地队列为空（图示 3 步骤）。
	- 如果 M1 的本地队列为空，P 从全局队列获取部分 G 到本队列（图示 3.1 步骤）。
	- 如果 M1 从本地队列获取不到 G ，P 从另一个线程 M2 的 P 偷取部分 G 到本地队列（图示 3.2 步骤）。

4. 调度 G ：
	- M1 获取到了就绪的 G 后， OS 调度器调度 CPU 执行 M1 ，进而 M1 执行 G （图示的 4 步骤）。

5. 执行 func()：
	- G 获取到执行权后，执行函数 func() （图示的 5 和 5.1 步骤）。
	- 如果 func() 发生了系统调用获阻塞， runtime 会 将 M1 从其绑定的 P 移除，再从休眠的 M 队列里获取或创建一个新的 M3 （图示的 5.2 步骤），并由 M3 继续接管 M1 释放的 P （图示的 5.3 步骤），此时 M3 接替 M1 的角色继续执行 P 的就绪的 G 。
	- 如果没有发生阻塞，执行完成之后销毁 G （图示的 6 步骤），并返回到 M1 （图示的 7 步骤），继续下一个新的循环。
	- M 获取 G 、调度 G 、执行 func() 、销毁 G 一起是一个循环机制。

6. 阻塞的 M 结束阻塞：
	- 当 M 系统调用完成，结束阻塞后，会尝试获取一个空闲的 P ，将这个 G 存放到这个空闲的 P 的本地队列，然后启动这个空闲的 P 。
	- 当找不到空闲的 P 的时候，则会将 G 存放到全局队列中。 

### 6. 调度器的生命周期
<center><img src=./source/52/6.调度器的生命周期.png width=400 float=center>

图6. 调度器的生命周期</center>

<br>

#### M0 和 G0
- M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G （即 main 函数的 G）， 在之后 M0 就和其他的 M 一样了，变成普通的 M 。
- G0 是每次启动一个 M 都会第一个创建的 goroutine ，G0 仅用于负责调度的 G ，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0 。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0 。

#### 跟踪一段代码分析生命周期
```
package main

import "fmt"

func main() {
    fmt.Println("Hello world")
}
```

1. runtime 创建第一个线程 M0 和 G0 ，并关联 M0 和 G0 。
2. 调度器初始化 M0 、栈、垃圾回收，创建和初始化 GOMAXPROCS 个 P 构成的 P 列表，完成了这些操作后 M0 就变成了普通的 M 了。
3. 示例代码中的 main 函数是 main.main ， runtime 也有一个 main 函数—— runtime.main ，编译后， runtime.main 会调用 main.main ，为 main.main 创建一个 G ，称为 G-main 吧。之后将 G-main 加入到 P 的本地队列。
4. 启动 M0 ， M0 绑定 P ，从 P 的本地队列获取到 G ，最初获取到的是 G-main 。
5. M 获取到 G 后，根据 G 拥有的栈信息和 P 的调度信息设置运行环境。
6. M 运行 G 。
7. G 退出后，再次获取可运行的 G ，继续重复。直到 main.main 退出， runtime.main 执行 defer 和 panic 处理，调用 runtime.exit 退出程序。
8. 如果 M 没有获取到 G ，则 M 进入睡眠状态，推入睡眠线程队列，直至 M 被唤醒。

调度器的生命周期占满了一个 Go 程序的一生， runtime.main 的 goroutine 执行之前都是为调度器做准备工作， runtime.main 的 goroutine 运行才是调度器的真正开始，直到 runtime.main 结束而结束。



	G 主要由以下集中状态：

		idle ： 刚刚被分配并且还没有被初始化，为创建 G 后的默认状态。
		runnable ： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中(如上图)。
		running： 正在执行代码的goroutine，拥有栈的所有权(如上图)。
		syscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列(如上图)。
		waiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列(如上图)。
		dead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine(如上图)。
		copystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在
		scan ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在

---
## 五、新版的 MGP 模型有哪些改进

---
## 总结


---
## 面试问题
1. 了解 GMP 模型吗，介绍一下？
2. 讲讲 golang 的调度模型，go 调度中阻塞都有那些方式
3. GPM 模型里如果本地队列满了，新增的 g 会怎么处理
	- 会与队列前半部分的g随机混合，然后取一半到全局队列
4. GO 语言中的协程与 Python 中的协程的区别？
5. Go 协程简单用法，goroutine的实现

---
## 提出新问题
1. 什么是锁竞争
2. 如果一个 G 阻塞了， 运行 G 的 M 也会阻塞？当有海量的 G 阻塞，也会创建海量的 M 吗
3. 如果本地 G 队列满了，新建的 G 到底是直接推入全局队列，还是会把一半的本地队列推入全局队列，还是将本地队列打散再一半推入全局队列。
4. 如果一个 M 阻塞了，会释放 P ，唤醒了之后又如何重新执行 P ？再从 P 队列获取空闲的 P ？
5. 为什么不能有一个睡眠 G 队列，进行阻塞/系统调用的 G 的存放？
	
	一个 G 是用户态线程，它需要依赖 M 才能执行，这当然也包括进行阻塞或系统调用，因此不可能存在睡眠 G 队列，因为 G 不可能脱离 M 进行阻塞/系统调用的操作。

---
## 参考文档
- [Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
- [Golang并发模型GMP](https://zhuanlan.zhihu.com/p/261057034)

---


- [9.2 Go 大杀器之跟踪剖析 trace](https://eddycjy.gitbook.io/golang/di-9-ke-gong-ju/go-tool-trace)
- [9.3 用 GODEBUG 看调度跟踪](https://eddycjy.gitbook.io/golang/di-9-ke-gong-ju/godebug-sched)